"use server";

import { revalidatePath } from "next/cache";
import { createClient } from "@/lib/supabase/server";
import type { PostgrestError } from "@supabase/supabase-js";
import { UUID } from "crypto";

export type InventoryActionState = {
  ok: boolean;
  error?: string;
};

type InventoryItem = {
  id: UUID;
  name: string;
  on_hand_qty: number;
  unit: string | null;
  density: number;
};

export async function addInventoryItem(
  _prevState: InventoryActionState,
  formData: FormData,
): Promise<InventoryActionState> {
  const supabase = await createClient();

  const name = String(formData.get("name") || "").trim();
  const quantityRaw = formData.get("quantity");
  const quantity = Number(quantityRaw);
  const unit = String(formData.get("unit") || "g").trim();

  if (!name) {
    return { ok: false, error: "Name is required" };
  }
  if (quantity !== null && (Number.isNaN(quantity) || quantity < 0)) {
    return { ok: false, error: "Quantity must be a non-negative number" };
    // If you want to allow null, remove the check for < 0.
  }

  const { count: nameCount, error: nameCheckError } = await supabase
    .from("inventory")
    .select("id", { count: "exact", head: true })
    .ilike("name", name);

  if (nameCheckError) {
    return {
      ok: false,
      error: `Couldn't verify uniqueness: ${nameCheckError.message}`,
    };
  }
  if ((nameCount ?? 0) > 0) {
    return { ok: false, error: "An item with that name already exists" };
  }

  const { error: insertError } = await supabase
    .from("inventory")
    .insert([{ name, on_hand_qty: quantity, unit } satisfies Partial<InventoryItem>]);

  if (insertError) {
    // Friendly handling of common cases
    if ((insertError as PostgrestError).code === "23505") {
      // Unique violation (if you later add a unique constraint)
      return {
        ok: false,
        error: "An item with that name or id already exists",
      };
    }
    if (insertError.message?.toLowerCase().includes("generated always")) {
      return {
        ok: false,
        error:
          'Your "id" column is "GENERATED ALWAYS" by Postgres. Either remove manual id assignment or switch it to "GENERATED BY DEFAULT".',
      };
    }
    return { ok: false, error: insertError.message };
  }

  revalidatePath("/meal-planning/inventory");
  return { ok: true };
}

/**
 * Update an inventory item.
 * Expects form fields: id (required), name (optional), quantity (optional)
 */
export async function updateInventoryItem(
  _prevState: InventoryActionState,
  formData: FormData,
): Promise<InventoryActionState> {
  const supabase = await createClient();

  const id = formData.get("id");

  const next: Partial<InventoryItem> = {};
  if (formData.has("name")) {
    next.name = String(formData.get("name") || "").trim();
    if (!next.name) return { ok: false, error: "Name cannot be empty" };
  }
  if (formData.has("quantity")) {
    const qRaw = formData.get("quantity");
    const q = Number(qRaw);
    if (q !== null && (Number.isNaN(q) || q < 0)) {
      return { ok: false, error: "Quantity must be a non-negative number" };
    }
    next.on_hand_qty = q;
  }
  if (formData.has("unit")) {
    const unitVal = String(formData.get("unit") || "").trim();
    if (unitVal) {
      next.unit = unitVal;
    }
  }

  if (Object.keys(next).length === 0) {
    return { ok: false, error: "No fields to update" };
  }

  const { error } = await supabase.from("inventory").update(next).eq("id", id);

  if (error) {
    return { ok: false, error: error.message };
  }

  revalidatePath("/meal-planning/inventory");
  return { ok: true };
}

/**
 * Delete an inventory item.
 * Expects form field: id (required)
 */
export async function deleteInventoryItem(
  _prevState: InventoryActionState,
  formData: FormData,
): Promise<InventoryActionState> {
  const supabase = await createClient();

  const id = formData.get("id");

  const { error } = await supabase.from("inventory").delete().eq("id", id);

  if (error) {
    return { ok: false, error: error.message };
  }

  revalidatePath("/meal-planning/inventory");
  return { ok: true };
}
