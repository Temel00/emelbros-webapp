"use server";

import { revalidatePath } from "next/cache";
import { createClient } from "@/lib/supabase/server";
import type { PostgrestError } from "@supabase/supabase-js";
import { UUID } from "crypto";
import { getUnitsForCategory } from "@/lib/unit-conversions";
import type { UnitCategory } from "@/components/unit-switcher";

export type InventoryActionState = {
  ok: boolean;
  error?: string;
};

export type InventoryItem = {
  id: UUID;
  name: string;
  on_hand_qty: number;
  unit: string;
  density: number;
  unit_category: "weight" | "volume" | "count" | null;
  location: "pantry" | "fridge" | "freezer" | "other" | null;
};

export type InventoryFetchResult = {
  items: InventoryItem[];
  hasMore: boolean;
  totalItems: number;
};

export async function fetchInventoryItems(
  loadNumber: number,
  search: string,
  category: string,
  itemsPerLoad: number,
): Promise<InventoryFetchResult> {
  const supabase = await createClient();

  let query = supabase.from("inventory").select("*", { count: "exact" });

  if (search) {
    query = query.ilike("name", `%${search}%`);
  }

  if (category !== "all") {
    const units = getUnitsForCategory(category as UnitCategory);
    query = query.in("unit", units);
  }

  const from = (loadNumber - 1) * itemsPerLoad;
  const to = from + itemsPerLoad - 1;

  const { data, error, count } = await query
    .order("name", { ascending: true })
    .range(from, to);

  if (error) {
    return { items: [], hasMore: false, totalItems: 0 };
  }

  const items = (data || []) as InventoryItem[];
  const totalItems = count ?? 0;

  return {
    items,
    hasMore: from + items.length < totalItems,
    totalItems,
  };
}

export async function addInventoryItem(
  _prevState: InventoryActionState,
  formData: FormData,
): Promise<InventoryActionState> {
  const supabase = await createClient();

  const name = String(formData.get("name") || "").trim();
  const quantityRaw = formData.get("quantity");
  const quantity = Number(quantityRaw);
  const unit = String(formData.get("unit") || "g").trim();
  const unitCategoryRaw = String(formData.get("unit_category") || "").trim();
  const unitCategory = (
    ["weight", "volume", "count"].includes(unitCategoryRaw)
      ? unitCategoryRaw
      : null
  ) as InventoryItem["unit_category"];
  const locationRaw = String(formData.get("location") || "").trim();
  const location = (
    ["pantry", "fridge", "freezer", "other"].includes(locationRaw)
      ? locationRaw
      : null
  ) as InventoryItem["location"];

  if (!name) {
    return { ok: false, error: "Name is required" };
  }
  if (quantity !== null && (Number.isNaN(quantity) || quantity < 0)) {
    return { ok: false, error: "Quantity must be a non-negative number" };
    // If you want to allow null, remove the check for < 0.
  }

  const { count: nameCount, error: nameCheckError } = await supabase
    .from("inventory")
    .select("id", { count: "exact", head: true })
    .ilike("name", name);

  if (nameCheckError) {
    return {
      ok: false,
      error: `Couldn't verify uniqueness: ${nameCheckError.message}`,
    };
  }
  if ((nameCount ?? 0) > 0) {
    return { ok: false, error: "An item with that name already exists" };
  }

  const { error: insertError } = await supabase
    .from("inventory")
    .insert([{ name, on_hand_qty: quantity, unit, unit_category: unitCategory, location } satisfies Partial<InventoryItem>]);

  if (insertError) {
    // Friendly handling of common cases
    if ((insertError as PostgrestError).code === "23505") {
      // Unique violation (if you later add a unique constraint)
      return {
        ok: false,
        error: "An item with that name or id already exists",
      };
    }
    if (insertError.message?.toLowerCase().includes("generated always")) {
      return {
        ok: false,
        error:
          'Your "id" column is "GENERATED ALWAYS" by Postgres. Either remove manual id assignment or switch it to "GENERATED BY DEFAULT".',
      };
    }
    return { ok: false, error: insertError.message };
  }

  revalidatePath("/dashboard/meal-planning/inventory");
  return { ok: true };
}

/**
 * Update an inventory item.
 * Expects form fields: id (required), name (optional), quantity (optional)
 */
export async function updateInventoryItem(
  _prevState: InventoryActionState,
  formData: FormData,
): Promise<InventoryActionState> {
  const supabase = await createClient();

  const id = formData.get("id");

  const next: Partial<InventoryItem> = {};
  if (formData.has("name")) {
    next.name = String(formData.get("name") || "").trim();
    if (!next.name) return { ok: false, error: "Name cannot be empty" };
  }
  if (formData.has("quantity")) {
    const qRaw = formData.get("quantity");
    const q = Number(qRaw);
    if (q !== null && (Number.isNaN(q) || q < 0)) {
      return { ok: false, error: "Quantity must be a non-negative number" };
    }
    next.on_hand_qty = q;
  }
  if (formData.has("unit")) {
    const unitVal = String(formData.get("unit") || "").trim();
    if (unitVal) {
      next.unit = unitVal;
    }
  }
  if (formData.has("unit_category")) {
    const ucRaw = String(formData.get("unit_category") || "").trim();
    next.unit_category = (
      ["weight", "volume", "count"].includes(ucRaw) ? ucRaw : null
    ) as InventoryItem["unit_category"];
  }
  if (formData.has("location")) {
    const locRaw = String(formData.get("location") || "").trim();
    next.location = (
      ["pantry", "fridge", "freezer", "other"].includes(locRaw)
        ? locRaw
        : null
    ) as InventoryItem["location"];
  }

  if (Object.keys(next).length === 0) {
    return { ok: false, error: "No fields to update" };
  }

  const { error } = await supabase.from("inventory").update(next).eq("id", id);

  if (error) {
    return { ok: false, error: error.message };
  }

  revalidatePath("/dashboard/meal-planning/inventory");
  return { ok: true };
}

/**
 * Delete an inventory item.
 * Expects form field: id (required)
 */
export async function deleteInventoryItem(
  _prevState: InventoryActionState,
  formData: FormData,
): Promise<InventoryActionState> {
  const supabase = await createClient();

  const id = formData.get("id");

  const { error } = await supabase.from("inventory").delete().eq("id", id);

  if (error) {
    return { ok: false, error: error.message };
  }

  revalidatePath("/dashboard/meal-planning/inventory");
  return { ok: true };
}
